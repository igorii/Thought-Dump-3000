var posts = [
  {  title: 'JavaScript Nonsense',
     date: 'Sat Sep 14 2013',
     content: '<pre style="text-align: center;"><span style="color: #800000;">(([]+!![])[+!![]+!![]+!![]])+</span><span style="color: #800000;">(([]+![])[+!![]+!![]])+</span><span style="color: #800000;">(([]+![])[+!![]+!![]])+(([]+{})[+!![]])</span></pre><p><strong>The above is valid JavaScript code</strong>. I generally enjoy programming in JavaScript, mainly due to it&#8217;s accessibility and immediate feedback. These are very compelling advantages of the language that are largely unparalleled by any other language. Because of these advantages, JavaScript makes an excellent language for working on quick projects, and it also provides an excellent resource for people new to programming: all you need to do is open a browser and type!</p><p>JavaScript does have a number of peculiarities, however. Among these is the <strong>crazy weak typing</strong>. This system lets you perform operations on data which may make no sense in terms of the operation. For example, I would expect that adding 1 to the empty object, such as `<span style="color: #800000;">1 + {}</span>`, would result in a type error&#8230; Nope! Surprise! According to JavaScript this equals `<span class="code" style="color: #800000;">&#8220;1[object Object]&#8220;</span>`. Fine, what is `<span style="color: #800000;">1 + +{}</span>`. JavaScript tells us the answer is none other than `<span style="color: #800000;">NaN</span>`. Well, that makes sense. Whatever the answer to that would be, it&#8217;s certainly <em>not a number</em>. Thanks JavaScript! So `1 + +[]` should also be `<span style="color: #800000;">NaN</span>` as well, right? Right?? Nope, this is in fact <em>a number</em>: 1 to be precise.</p><p> <a href="http://timthornton.net/javascript-nonsense/#more-223" class="more-link">Continue reading &rarr;</a></p>'
  },
  {  title: 'Writing Literate Haskell with Code Block Notation',
     date: 'Sun Sep 15 2013',
     content: '<p><a href="https://github.com/igorii/block2bb">GitHub</a></p><h2 id="description">Description</h2><p>A few nights ago I wrote a <em>very</em> simple &#8220;parser&#8221; for Literate Haskell files that use a TeX-like notation for denoting blocks of code. The format expected by the program is: {code} -&gt; begins a block of code {endCode} -&gt; ends a block of code Both blocks of code and Bird Beak lines are converted to Bird Beak notation to be compiled. All other lines are considered comments.</p><h2 id="reasoning">Reasoning</h2><p>There are many advantages to using a block notation rather than &#8216;&gt;&#8217; on each line, especially for larger blocks of code. To read a few reasons against standard Literate Haskell, see <a href="http://unspecified.wordpress.com/2010/06/04/literate-programming-is-a-terrible-idea/">this</a> post by Matt Giuca. While I quite enjoy Literate Programming, many of the arguments he puts forth address troublesome aspects of literate programming, but they are mostly tightly coupled to the notation used.</p><h2 id="use"> <a href="http://timthornton.net/writing-literate-haskell-with-code-block-notation/#more-213" class="more-link">Continue reading &rarr;</a></h2>'
  },
  {  title: 'Haskell Chess',
     date: 'Sun Sep 15 2013',
     content: '<h1 id="haskell-chess"><a style="font-size: 17px; font-weight: 100;" href="https://github.com/igorii/HChess">GitHub</a></h1><p>This is my first attempt at writing a useful Haskell program. I am currently reading the wonderful &#8220;Haskell School of Expression&#8221; Book by Paul Hudak of Yale. I am finding Haskell extremely intriguing and thought I would take a stab at creating a Chess application (console-based) in Haskell. The application works via the <a href="https://en.wikipedia.org/wiki/Honor_system">honor system</a>. I&#8217;ve decided to put this project on hold while I learn more so that I can more effectively implement an AI and a move validator.</p><p>In any case, here is my first attempt at Haskell&#8230;</p><p>Since the application is a single file, I&#8217;ve declared this as the Main module.</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></code></pre><p>I&#8217;ve then imported some packages for list operations and the Maybe data type.</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import</span> Data.List.Split<span class="kw">import</span> Data.List<span class="kw">import</span> Data.Maybe<span class="kw">import</span> Data.Char</code></pre><p>Here I define the <em>algebraic data types</em> I&#8217;ll be using in the application. <code>Player</code> will reflect the two types of players in the game, White and Black.</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Player</span>     <span class="fu">=</span> <span class="dt">White</span>                 <span class="fu">|</span> <span class="dt">Black</span>    <span class="kw">deriving</span> (<span class="kw">Show</span>, <span class="kw">Eq</span>)</code></pre><p> <a href="http://timthornton.net/haskell-chess/#more-197" class="more-link">Continue reading &rarr;</a></p>'
  }
];

exports.blog = function (req, res) {
  res.end(JSON.stringify(posts));
};